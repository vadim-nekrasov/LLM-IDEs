---
description: Apply when a task needs analysis and implementation via editing files.
globs: 
alwaysApply: false
---

# Task Implementation Pipeline

Follow this pipeline strictly for every non-trivial task or when `submit` rule is active.

## Phase 1: Analysis & Confidence Check

**Context**: Adopt the **10x Senior Expert** persona and the **Three Lenses** defined in `.cursor/rules/expert-mindset.mdc`.

1.  **Structured Analysis**:
    - Before writing any code, analyze the user request to identify:
        - Core problem vs. symptoms.
        - Implicit vs. explicit requirements.
        - Success criteria.

2.  **Role-Based Pre-Analysis (Mental Sandbox)**:
    - Briefly view the task through the three lenses *before* planning:
        - Product, Architect, Maintainer.
    - **Reference**: See `.cursor/rules/expert-mindset.mdc` for detailed definitions.

3.  **Confidence Threshold (80%)**:
    - Assess your confidence in understanding the task.
    - If confidence < 80% on **critical** business logic or safety requirements, **ASK clarifying questions** first.
    - For non-critical ambiguities:
        - Make **reasonable assumptions**, explicitly state them in your plan, and proceed.
        - Do not block progress for minor details.

4.  **Constraints & Questions Detection**:
    - **Constraint Identification**:
        - If the prompt contains a block with "ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ" in the title (e.g., "Ð—Ð°Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ"), treat its content as strict `strict_constraints`.
    - **Question Identification**:
        - If the prompt contains a block with "Ð’Ð¾Ð¿Ñ€Ð¾Ñ" or "Ð’Ð¾Ð¿Ñ€Ð¾ÑÑ‹" in the title (e.g., "ÐšÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð²Ð°Ð¶Ð½Ñ‹Ðµ Ð²Ð¾Ð¿Ñ€Ð¾ÑÑ‹"), treat its content as `questions_answered`.
        - You MUST answer these questions during the investigation phase.

## Phase 2: Documentation & Context (The Docs-First Checklist)

### When to SKIP Documentation

You may skip the "Internal Documentation" step ONLY if **all** are true:

- The task is a local/atomic fix within one file (typo, local variable rename, formatting).
- The user explicitly said "don't check docs".
- The change definitely does not affect contracts, external behavior, or business logic.

### Internal Documentation (Docs-First)
**If checking documentation is required (default), perform this checklist:**

1.  **Discovery**:
    - [ ] Locate all `docs` folders on the path from the edited files to the project root.
    - [ ] Read relevant `.md` / `.mdc` files (specs, architecture, contracts).
2.  **Compliance**:
    - [ ] Extract 3-5 key invariants/contracts from docs.
    - [ ] **Crucial**: Explicitly list these invariants in your reasoning/analysis block to ensure alignment.
    - [ ] If your plan contradicts docs:
        - **Option A**: Update docs (if code is right and docs are stale).
        - **Option B**: Adjust plan (if docs are the source of truth).
3.  **Updates**:
    - [ ] If you change architecture, API, file structure, or configuration â€” **UPDATE DOCS**.
    - Keep docs in English.

### External Documentation (Context7)
1.  **Zero Hallucination Policy**:
    - Do not guess API signatures for third-party libraries.
    - If you need to use a library (React, Next.js, etc.) and are not 100% sure of the *current* version's API:
        - Use `mcp_context7_resolve-library-id` to find the library.
        - Use `mcp_context7_get-library-docs` to fetch actual docs/examples.
    - **Always** use Context7 for setup, configuration, or complex API usages.
    - **Policy**: Adhere to the "Zero Hallucination" policy in `.cursor/rules/expert-mindset.mdc`.

---

## Phase 3: Solution Architecture â€” MANDATORY Tree Search Gate

> **âš ï¸ CRITICAL**: This phase is a **MANDATORY GATE**. You MUST NOT proceed to Phase 4 (Implementation) until you have completed Solution Tree Search and produced the required artifacts.

### Why Tree Search is Non-Negotiable

LLMs (including you) have a natural tendency to jump to the first plausible solution to conserve tokens. This leads to:
- Suboptimal architectural decisions that are expensive to fix later.
- Missing edge cases and alternative approaches.
- Technical debt from unexplored trade-offs.

**Tree Search forces systematic exploration before commitment.**

---

### Step 1: Complexity Assessment (Default = COMPLEX)

**Default Assumption**: The task is **COMPLEX** and requires full Tree Search.

> **ðŸ“„ Source of Truth**: All complexity criteria, simplicity conditions, and skip keywords are defined in:
> **`.cursor/rules/task-classification.mdc`**
>
> Read that file to determine the correct classification. Do not rely on memory.

**Classification outcomes:**
- **COMPLEX** â†’ Full Tree Search (15+ variants)
- **SIMPLE** â†’ Reduced Tree Search (5 variants)
- **TRIVIAL** â†’ No Tree Search (mechanical edit, skip to Phase 4)
- **SKIPPED** â†’ User override, skip to Phase 4

---

### Step 2: Execute Tree Search (if applicable)

**If complexity is COMPLEX or SIMPLE:**
1. **First, READ the command file**: Use `read_file` tool to load `.cursor/commands/solution-tree-search.md`. Do NOT rely on memory â€” the file may have been updated.
2. **Then, EXECUTE the process** as defined in that file.

Use the default parameters from the command file. Do NOT hardcode numbers here to avoid sync issues.

**If complexity is TRIVIAL or SKIPPED:**
- **Do NOT run Tree Search.** Output the Complexity Declaration, then proceed directly to Phase 4.

#### Reasoning Guidelines (from command file):
- **Arguments > Authority**: The logic matters, not the source.
- **Flag Speculation**: Mark uncertain claims ("I suspect...", "Hypothetically...").
- **Justify Selection**: Explicitly explain why the chosen option wins over alternatives.

#### Required Output Artifacts

> **Note**: The tree search process (brainstorming, full tree exploration) happens **internally**. 
> Output only the **final results** below â€” do NOT dump all 15+ variants or the full tree structure.

1. **Complexity Declaration** (1 line):
   ```
   Complexity: [COMPLEX | SIMPLE | TRIVIAL | SKIPPED] â€” [brief reason]
   ```

**If COMPLEX or SIMPLE** â€” continue with:

2. **Top Candidates** (2-3 finalists, 1 line each):
   - Candidate A: [name] â€” Pro: [...], Con: [...]
   - Candidate B: [name] â€” Pro: [...], Con: [...]

3. **Selected Solution Specification**:
   - **Summary**: 1-2 sentences.
   - **Components**: Key modules/classes (3-5 bullets).
   - **Data Flow**: How data moves through the system (2-3 bullets).
   - **Extension Points**: Where future growth can happen (1-2 bullets).
   - **Blueprint**: Files to create/edit with responsibilities.

**If TRIVIAL or SKIPPED** â€” skip items 2-3, proceed to Phase 4.

---

### Step 3: Gate Validation (Output Structure Requirement)

> **â›” FAILURE CONDITION**: If your response does NOT contain the `## Architecture & Planning` section with the artifacts above, you have **failed** this phase. Go back and produce them before any code.

After the `## Architecture & Planning` section is complete and all artifacts are present:
- **Proceed directly to Phase 4 (Implementation).**
- **Do NOT ask the user for confirmation** of the chosen solution, unless they explicitly requested to review the plan first.

---

## Phase 4: Implementation Standards

> **Prerequisite**: Phase 3 Gate Validation must be complete.

### Code Style
- **Reference**: Follow rules in `.cursor/rules/ecmascript-code-style.mdc`.
- **Mindset**: Apply the **Maintainer Lens** from `.cursor/rules/expert-mindset.mdc`.
- **Readability**: Prioritize readability and maintainability over premature optimization. Write code that is easy to understand for other developers.

### Comments Hygiene
- **Sync**: When changing logic, update or delete related comments immediately.
- **No Zombies**: Do not leave commented-out old code. Delete it.
- **Clarity**: Keep comments concise and relevant to the *current* state of code.

### Logging & Debugging
- If the cause of a bug is unclear, do not patch logic blindly. Add logs.
- **Object Logging**: Remember that browsers/terminals often collapse objects (`{...}`).
    - Use `JSON.stringify(obj, null, 2)` or log specific fields for clarity.
    - Or use explicit labels: `console.log('Var Name:', value)`.

### Refactoring & Legacy Code
- **New Code**:
    - MUST adhere strictly to `ecmascript-code-style.mdc` and Best Practices.
    - Zero tolerance for bad patterns in new lines of code.
- **Existing (Legacy) Code**:
    - **Conservative Approach**: Do not refactor legacy code just for style unless it blocks the task or is explicitly requested.
    - **Refactoring Opportunity**: If legacy code violates SOLID/DRY/KISS to the point where it makes the task dangerous or impossible to do cleanly â€” **Plan a refactor** and ask the user (or include it in the solution if authorized).

## Phase 5: Verification Trigger

> **Mandatory Action**: Upon completion of code edits, you MUST execute the rule:
> **`.cursor/rules/final-checks.mdc`**
>
> **Exception**: You may skip this rule ONLY if the changes were exclusively non-logic updates (e.g., adding console
> logs, comments, or fixing typos in documentation).
>
> This rule serves as the strict gatekeeper for all logic changes. Do not verify manually here; delegate to `final-checks`.

## Communication
- **Conciseness**: Be concise. Tree Search happens internally; only output the compact final result.
- **Language**:
    - Final Response to User: **Russian**.
    - Internal Reasoning / Thinking Blocks (**if** generated): **English** (for better logic quality and token efficiency).
