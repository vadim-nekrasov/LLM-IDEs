---
globs: *.tsx,*.ts,*.jsx,*.js
alwaysApply: false
---

# Code Style & Modern JS/TS Usage (2025)

Используй современные возможности языка **там, где это повышает читаемость и уменьшает бойлерплейт**, без ущерба для
производительности.

Под «современным JS/TS» подразумеваются, в частности:

- optional chaining, nullish coalescing, логические присваивания (??= ||= &&=);
- Iterator Helpers (`Iterator.from`, `.map/.filter/.take/.drop/.find/.toArray` и т.д.);
- новые методы `Set` (`intersection`, `union`, `difference`, `symmetricDifference`,
  `isSubsetOf`, `isSupersetOf`, `isDisjointFrom` и др.);
- иммутабельные методы массивов (`toSorted`, `toReversed`, `toSpliced` и т.п.);
- `Object.groupBy`, `Promise.withResolvers`, `Promise.try`, `structuredClone`, `Intl.*` и т.д.

## Общие предпочтения среды и стиля

- **Целевая среда** — только **последний Chrome** (актуальная спецификация JS 2025).  
  Можно смело использовать всё современное API итераторов и другие новые возможности языка.
- **Функциональный стиль** предпочтительнее императивного, если это **не ухудшает производительность**
  и не делает код менее понятным.
- Там, где это возможно без ущерба, заменяй императивные циклы (`for`, `for...of`, `while`)
  на функциональные конструкции:
    - методы массивов (`map`, `filter`, `reduce`, `flatMap`, `some`, `every` и т.п.),
    - Iterator Helpers,
    - операции над `Set`.
- Во многих случаях **итераторы предпочтительнее массивов**, особенно:
    - при работе с потенциально большими/ленивыми источниками (генераторы, потоки, стримы);
    - при необходимости **ранней остановки** (`find`, `take`, `drop`) без полной материализации;
    - при реализации одноразовых проходов по данным без промежуточных больших массивов.
- По возможности старайся формулировать логику так, чтобы **использовать `const` вместо `let`**:
    - вместо внешних «счётчиков» и аккумуляторов с `let` используй `reduce`, ленивые итераторы и чистые функции.

---

# Optional Chaining

**Плохо / Хорошо**

```js
// ❌ Плохо
if (user && user.profile && user.profile.address) {
  const city = user?.profile?.address?.city;
}

// ✅ Хорошо
const city = user?.profile?.address?.city ?? 'Unknown';
````

```js
// ❌ Плохо
typeof maybeFn === 'function' && maybeFn();

// ✅ Хорошо
maybeFn?.();
```

---

# Nullish Coalescing (??)

```js
// ❌ Плохо — 0 и '' считаются пустыми
const limit = opts.limit || 20;

// ✅ Хорошо
const limit = opts.limit ?? 20;
```

---

# Логические присваивания (??= ||= &&=)

```js
// ❌ Плохо
if (cfg.retries === null || cfg.retries === undefined) {
  cfg.retries = 3;
}

// ✅ Хорошо
cfg.retries ??= 3;
```

```js
// ❌ Плохо — смешение логики и побочных эффектов
connected &&= ping();

// ✅ Хорошо
connected = connected ? ping() : false;
```

---

# Iterator Helpers

## Общие правила

Используй Iterator Helpers, когда это даёт преимущества:

* Источник — **не массив** (генераторы, ленивые коллекции, потоки), а материализация в массив не нужна.
* Нужна **ранняя остановка** (например, `find`, `take`, `drop`) без создания больших промежуточных массивов.
* Нужна «чистая» редукция из `Map`/`Set`/итератора в некоторую итоговую структуру за **один проход**,
  без нескольких последовательных `.map/.filter/.slice` и т.п.
* При этом, если у коллекции уже есть **простой и читаемый метод** (например, `map`, `filter` у массива),
  не стоит заменять его на итератор только ради итератора.

ЛЮБЫЕ итераторы, в том числе возвращаемые методами прототипов `Array.prototype`, `Map.prototype` и `Set.prototype`
(такими как `.keys()`, `.values()`, и т.д.), уже наследуют `Iterator.prototype` и напрямую поддерживают helper-методы
(`.reduce`, `.map`, `.some` и т.д.). При необходимости создания итератора оборачивай в `Iterator.from()` только
**итерируемые** источники, не являющиеся итераторами (массивы, Set, Map, генераторы и т.п.).

### Нормализация входа

```js
// ❌ Плохо — самописный конструктор итераторов
const toIterator = x =>
  x && typeof x[Symbol.iterator] === 'function'
    ? x[Symbol.iterator]()
    : x && typeof x.next === 'function'
      ? x
      : [][Symbol.iterator]();

// ✅ Хорошо — единый путь
const it = Iterator.from(maybeIterableOrIterator);
```

## Фильтрация, маппинг и ограничение

```js
// ❌ Не нужно оборачивать готовые итераторы массивов
// Плохо
Iterator.from(Array(n).keys()).map(i => i + 1).toArray();

// ✅ Хорошо — в ES2025 встроенные итераторы наследуют Iterator Helpers
Array(n).keys().map(i => i + 1).toArray();
```

```js
// ❌ Плохо — ручные циклы
function* naturals() { let i = 1; while (true) yield i++; }
const it = naturals();
const out = [];
while (out.length < 5) {
  const n = it.next().value;
  if (n % 2 === 0) out.push(n * n);
}

// ✅ Хорошо — лениво, читаемо
const out = naturals()
  .filter(n => n % 2 === 0)
  .map(n => n * n)
  .take(5)
  .toArray();
```

## Пагинация без лишних массивов

```js
// ❌ Плохо — материализация целого массива
const arr = Array.from(iterable);
const pageItems = arr.slice(page * size, page * size + size);

// ✅ Хорошо
const pageItems = Iterator.from(iterable)
  .drop(page * size)
  .take(size)
  .toArray();
```

## Окно: «пропусти N, возьми M» из большого источника

```js
// ❌ Плохо — полная материализация
const win = Array.from(events).slice(offset, offset + limit);

// ✅ Хорошо — ленивое окно
const win = Iterator.from(events)
  .drop(offset)
  .take(limit)
  .toArray();
```

## Топ-N

```js
// ❌ Плохо — массивы и мутации
const top10 = Array.from(items)
  .map(x => ({ x, score: scoreOf(x) }))
  .sort((a, b) => b.score - a.score)
  .slice(0, 10)
  .map(v => v.x);

// ✅ Хорошо — лениво, только финальная материализация
const top10 = Iterator.from(items)
  .map(x => ({ x, score: scoreOf(x) }))
  .toArray()
  .toSorted((a, b) => b.score - a.score)
  .slice(0, 10)
  .map(v => v.x);
```

## Ранняя остановка / «бесконечные» источники

```js
// ❌ Плохо — зависание / OOM
Array.from(naturals()).find(...);

// ✅ Хорошо
const found = naturals().find(n => n % 12345 === 0);
```

---

# Работа с файлами и потоками

```js
// ❌ Плохо — сначала собрать всё
const lines = Array.from(readLines(stream));
const first = lines.find(l => l.includes(key));

// ✅ Хорошо — читаем по мере необходимости
const first = readLines(stream).find(l => l.includes(key));
```

---

# Set Operations (intersection / union / difference / symmetricDifference / isSubsetOf ...)

```js
// ❌ Плохо — O(n²)
const common = arrA.filter(x => arrB.includes(x));

// ✅ Хорошо
const common = new Set(arrA).intersection(new Set(arrB));
```

```js
// ❌ Плохо — мутации
for (const v of b) if (a.has(v)) a.delete(v);

// ✅ Хорошо
const diff = new Set(a).difference(new Set(b));
```

```js
// ❌ Плохо — ручной XOR через массивы
const sym = [
  ...arrA.filter(x => !arrB.includes(x)),
  ...arrB.filter(x => !arrA.includes(x)),
];

// ✅ Хорошо
const sym = new Set(arrA).symmetricDifference(new Set(arrB));
```

```js
// ❌ Плохо — O(n·m) и проблемы с дубликатами
const isSub = arrA.every(x => arrB.includes(x));

// ✅ Хорошо
const isSub = new Set(arrA).isSubsetOf(new Set(arrB));
```

```js
// ❌ Плохо
const isSuper = arrB.every(x => arrA.includes(x));

// ✅ Хорошо
const isSuper = new Set(arrA).isSupersetOf(new Set(arrB));
```

```js
// ❌ Плохо
const disjoint = arrA.every(x => !arrB.includes(x));

// ✅ Хорошо
const disjoint = new Set(arrA).isDisjointFrom(new Set(arrB));
```

---

# Иммутабельные методы массивов

```js
// ❌ Плохо — мутирует
nums.sort((a, b) => a - b);

// ✅ Хорошо
const sorted = nums.toSorted((a, b) => a - b);
```

---

# Object.groupBy

```js
// ❌ Плохо
const groups = {};
for (const u of users) (groups[u.role] ??= []).push(u);

// ✅ Хорошо
const byRole = Object.groupBy(users, u => u.role);
```

---

# Работа с Promise / Error Handling

## Promise.withResolvers

```ts
// ❌ Плохо — потерян reject
let holder!: Promise<string>;
{
  const { promise, resolve } = Promise.withResolvers<string>();
  holder = promise;
  setTimeout(() => resolve('done'), 100);
}

// ✅ Хорошо
const { promise, resolve, reject } = Promise.withResolvers<string>();
const timeout = setTimeout(() => reject(new Error('timeout')), 5000);
doAsync().then(v => {
  clearTimeout(timeout);
  resolve(v);
});
await promise;
```

## Promise.try

```js
// ❌ Плохо — sync ошибка не превращается в reject
new Promise(resolve => resolve(callback()));

// ✅ Хорошо
Promise.try(callback).then(handle).catch(report);
```

## Унификация sync/async

```js
// ❌ Плохо
function runMaybe(fn) {
  try {
    const r = fn();
    return Promise.resolve(r);
  } catch (e) {
    return Promise.reject(e);
  }
}

// ✅ Хорошо
const runMaybe = fn => Promise.try(fn);
```

## Единый try/catch-поток

```js
// ❌ Плохо — смешанный стиль
try {
  const data = await maybeSyncOrAsync();
  return doSomething(data);
} catch (e) {
  return handle(e);
}

// ✅ Хорошо
await Promise.try(() => maybeSyncOrAsync())
  .then(doSomething)
  .catch(handle);
```

## Массовая обработка «сомнительных» колбэков

```js
// ❌ Плохо
const results = await Promise.all(
  tasks.map(task => {
    try {
      return task();
    } catch (e) {
      return Promise.reject(e);
    }
  }),
);

// ✅ Хорошо
const results = await Promise.all(
  tasks.map(task => Promise.try(task)),
);
```

## Универсальная обёртка для внешних callbacks

```js
// ✅ Хорошо — единый интерфейс для sync/async-хуков
export const compute = (input, { onCompute } = {}) =>
  Promise.try(() => onCompute?.(input))
    .then(res => merge(input, res))
    .catch(reportAndFallback);
```

---

# Deep Clone

```js
// ❌ Плохо — ломает Date/Map/циклы
const copy = JSON.parse(JSON.stringify(obj));

// ✅ Хорошо
const copy = structuredClone(obj);
```

---

# Intl API

```js
// ❌ Плохо
const price = 'RUB ' + Math.round(value * 100) / 100;

// ✅ Хорошо
const fmt = new Intl.NumberFormat('ru-RU', {
  style: 'currency',
  currency: 'RUB',
});
const price = fmt.format(value);
```

---

# Performance & Optimization

* Избегай полной материализации больших коллекций, когда достаточно ленивых итераторов.
* Используй Iterator Helpers и операции над `Set`, если они дают выигрыш в читаемости и не вредят производительности.
* Следи за отсутствием утечек памяти: не держи лишние ссылки на большие структуры.
* Кешируй тяжёлые вычисления и сетевые запросы, если они многократно переиспользуются.
* Эффективно обрабатывай асинхронные операции:

    * не создавай лишних `await` в цепочках;
    * по возможности выполняй независимые задачи параллельно (`Promise.all`).

---

# Security

* Не доверяй входным данным.
* Избегай прямого использования непроверенного HTML.
* Учитывай XSS и инъекции при работе со строками и внешними источниками.
* Следи за тем, чтобы в коде не появлялись очевидные места для SQL/NoSQL-инъекций и небезопасной сериализации.

---

# Console Logs (Debugging)

Если есть сомнения в причине бага — **добавляй рабочие `console.log`**, которые реально помогут разобраться:

* Логируй **ключевые входные данные и промежуточные состояния**.
* Помни, что в браузерной консоли объекты при копировании могут превращаться в строку вида `"{}"` / `"{...}"`.
  Чтобы удобно копировать данные в текстовом виде, используй сериализацию:

```js
console.log('payload:', JSON.stringify(payload, null, 2));
```

Позже логи можно удалить, но на момент диагностики они должны быть **рабочими**, а не закомментированными.

---

# Code Style Guidelines

* Используй **ранние `return`**, чтобы избегать лишней вложенности.
* Обработчики событий называй с префиксом `handle`:

    * `handleClick`, `handleKeyDown`, `handleSubmit` и т.п.
* Используй **говорящие имена**: `isLoading`, `hasPermission`, `hasError`, `itemsById`.
* Предпочитай **тернарный оператор** вместо `if/else`, если это не создаёт вложенных тернарников
  и код остаётся читаемым.
* Предпочитай **функциональный стиль**:

    * `map`, `filter`, `reduce`, `flatMap`, `some`, `every`;
    * Iterator Helpers;
    * операции над `Set`.
* По возможности избегай `let`: стремись формулировать код так, чтобы использовать `const`
  (особенно для аккумуляторов через `reduce` и итераторы).
* Пиши **стрелочные функции**, по возможности без скобок вокруг единственного аргумента.
* Помни про hoisting: стрелочные функции **не поднимаются**, не используй их до объявления.

---

# Avoiding Problems

* Не смешивай логические операции и побочные эффекты (особенно с `&&=` и `||=`).
* Все итерирующие методы, кроме `forEach`, считаем «чистыми»: внутри `map`/`filter`/`reduce`/`flatMap`/`some`/`every` и
  т.п. **нет сайд-эффектов**, кроме мутации локальных временных структур (например, аккумулятора `reduce`).
  Сайд-эффекты — только в `forEach` или в отдельных функциях.
* Не мутируй аргументы функций без крайней необходимости.
* Не оборачивай уже готовые итераторы в `Iterator.from`.
* Следи за единообразием обработки sync/async путей (предпочитай `Promise.try` там, где это уместно).
* Избегай избыточных промежуточных массивов, если можно обойтись ленивыми итераторами.

